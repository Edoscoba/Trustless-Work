# Price Oracle Experimental Report

## Links

- **Reflector Website**: [https://reflector.network/](https://reflector.network/)
- **GitHub Repository**: [https://github.com/kalepail/reflector-boilerplate](https://github.com/kalepail/reflector-boilerplate)
- **Tutorial Video**: [YouTube Video](https://www.youtube.com/watch?v=Ow-HrNd88WA)

## Overview

This report evaluates Reflector as a price oracle for Stellar and external assets. The goal is to assess its reliability, security, and functionality in decentralized applications.

## How Reflector Works

- Uses a multisig-protected consensus (>50% node agreement) for price validation.
- Nodes independently fetch trade data from Stellar Core and external sources.
- Transactions with mismatched hashes are discarded, ensuring data integrity.
- Price feeds update every 5 minutes with 24-hour data retention.

## Key Features

- **Reliable Pricing**: Fetches accurate, real-time price feeds.
- **Cross-Price Computation**: Supports asset pair price calculations.
- **Historical Data**: Retains price records for trend analysis.
- **TWAP Support**: Provides time-weighted average pricing.

## Observations

- **Accurate & Secure**: Prices match major exchanges; multisig prevents manipulation.
- **Latency Risks**: Occasional trade data sync delays.
- **Stale Data Handling**: Always check timestamps before using price data.

## Best Practices

1. Verify price timestamps to avoid stale data.
2. Use TWAP for smoother pricing in volatile markets.
3. Consider multiple oracles for redundancy.
4. Use proxy contracts for flexible oracle switching.

## Code Implementation

## Reflector Contract Interface

```rust
// generated by calling
// `stellar contract bindings rust --wasm target/wasm32-unknown-unknown/release/reflector_oracle.wasm`
// after building the contract from https://github.com/reflector-network/reflector-contract

#[soroban_sdk::contractclient(name = "Client")]
pub trait Contract {
    fn base(env: soroban_sdk::Env) -> Asset;
    fn decimals(env: soroban_sdk::Env) -> u32;
    fn resolution(env: soroban_sdk::Env) -> u32;
    fn period(env: soroban_sdk::Env) -> Option<u64>;
    fn assets(env: soroban_sdk::Env) -> soroban_sdk::Vec<Asset>;
    fn last_timestamp(env: soroban_sdk::Env) -> u64;
    fn price(env: soroban_sdk::Env, asset: Asset, timestamp: u64) -> Option<PriceData>;
    fn lastprice(env: soroban_sdk::Env, asset: Asset) -> Option<PriceData>;
    fn prices(
        env: soroban_sdk::Env,
        asset: Asset,
        records: u32,
    ) -> Option<soroban_sdk::Vec<PriceData>>;
    fn x_last_price(
        env: soroban_sdk::Env,
        base_asset: Asset,
        quote_asset: Asset,
    ) -> Option<PriceData>;
    fn x_price(
        env: soroban_sdk::Env,
        base_asset: Asset,
        quote_asset: Asset,
        timestamp: u64,
    ) -> Option<PriceData>;
    fn x_prices(
        env: soroban_sdk::Env,
        base_asset: Asset,
        quote_asset: Asset,
        records: u32,
    ) -> Option<soroban_sdk::Vec<PriceData>>;
    fn twap(env: soroban_sdk::Env, asset: Asset, records: u32) -> Option<i128>;
    fn x_twap(
        env: soroban_sdk::Env,
        base_asset: Asset,
        quote_asset: Asset,
        records: u32,
    ) -> Option<i128>;
    fn version(env: soroban_sdk::Env) -> u32;
    fn admin(env: soroban_sdk::Env) -> Option<soroban_sdk::Address>;
    fn config(env: soroban_sdk::Env, config: ConfigData);
    fn add_assets(env: soroban_sdk::Env, assets: soroban_sdk::Vec<Asset>);
    fn set_period(env: soroban_sdk::Env, period: u64);
    fn set_price(env: soroban_sdk::Env, updates: soroban_sdk::Vec<i128>, timestamp: u64);
    fn update_contract(env: soroban_sdk::Env, wasm_hash: soroban_sdk::BytesN<32>);
}
#[soroban_sdk::contracttype(export = false)]
#[derive(Debug, Clone, Eq, PartialEq, Ord, PartialOrd)]
pub struct ConfigData {
    pub admin: soroban_sdk::Address,
    pub assets: soroban_sdk::Vec<Asset>,
    pub base_asset: Asset,
    pub decimals: u32,
    pub period: u64,
    pub resolution: u32,
}
#[soroban_sdk::contracttype(export = false)]
#[derive(Debug, Clone, Eq, PartialEq, Ord, PartialOrd)]
pub struct PriceData {
    pub price: i128,
    pub timestamp: u64,
}
#[soroban_sdk::contracttype(export = false)]
#[derive(Debug, Clone, Eq, PartialEq, Ord, PartialOrd)]
pub enum Asset {
    Stellar(soroban_sdk::Address),
    Other(soroban_sdk::Symbol),
}
#[soroban_sdk::contracterror(export = false)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
pub enum Error {
    AlreadyInitialized = 0,
    Unauthorized = 1,
    AssetMissing = 2,
    AssetAlreadyExists = 3,
    InvalidConfigVersion = 4,
    InvalidTimestamp = 5,
    InvalidUpdateLength = 6,
    AssetLimitExceeded = 7,
}
```

### `price_oracle.rs`

```rust
use crate::core::reflector_oracle::{Asset, Client, PriceData};
use crate::storage::types::oracle_key;
use soroban_sdk::{contract, contractimpl, Address, Env};

#[contract]
pub struct PriceOracle;

#[contractimpl]
impl PriceOracle {
    pub fn initialize_oracle(env: Env, oracle_address: Address) -> bool {
        env.storage().instance().set(&oracle_key, &oracle_address);
        true
    }

    pub fn fetch_price(env: &Env, asset: Asset) -> PriceData {
        let reflector_contract_id = match env.storage().instance().get(&oracle_key) {
            Some(x) => x,
            None => panic!("Please_initialize_oracle"),
        };

        let reflector_contract = Client::new(env, &reflector_contract_id);

        let asset_price: Option<PriceData> = reflector_contract.lastprice(&asset);

        match asset_price {
            Some(x) => x,
            None => panic!("failed_to_fetch_price"),
        }
    }

    pub fn checks_price_condition(
        env: Env,
        asset: Asset,
        target_price: i128,
        amount: i128,
    ) -> bool {
        let current_price = Self::fetch_price(&env, asset);
        current_price.price * amount >= target_price
    }
}
```

### `escrow.rs`

```rust
pub fn release_funds(e: Env) -> Result<(), ContractError> {
    let escrow_result = Self::get_escrow(e.clone());
    let mut escrow = match escrow_result {
        Ok(esc) => esc,
        Err(err) => return Err(err),
    };

    if escrow.release_flag {
        return Err(ContractError::EscrowAlreadyReleased);
    }

    let asset = Asset::Stellar(escrow.trustline.clone());

    let price_met = PriceOracle::checks_price_condition(
        e.clone(),
        asset,
        escrow.target_price,
        escrow.amount,
    );

    if price_met {
        let token_approver = TokenClient::new(&e, &escrow.trustline);
        let contract_address = e.current_contract_address();
        let contract_balance = token_approver.balance(&contract_address);

        if contract_balance < escrow.amount as i128 {
            return Err(ContractError::EscrowBalanceNotEnoughToSendEarnings);
        }

        token_approver.transfer(&contract_address, &escrow.service_provider, &escrow.amount);
        escrow.release_flag = true;
        escrow.resolved_flag = true;
        escrow.amount = 0;

        e.storage().instance().set(&DataKey::Escrow, &escrow);

        e.events().publish(
            (
                Symbol::new(&e, "funds_released"),
                escrow.engagement_id.clone(),
            ),
            (escrow.service_provider.clone(), escrow.amount),
        );
    }

    Ok(())
}
```

### Test Implementation

#### `test_price_oracle.rs`

```rust
#![cfg(test)]
use crate::core::reflector_oracle::Asset;
use crate::core::{PriceOracle, PriceOracleClient};
extern crate std;
use std::println;
use soroban_sdk::{symbol_short, testutils::EnvTestConfig, Address, Env, String};

#[test]
fntest_price_oracle() {
    let mut env = Env::from_ledger_snapshot_file("../../../../snapshot.json");
    env.set_config(EnvTestConfig {
        capture_snapshot_at_drop: false,
    });

    let contract_id = env.register_contract(None, PriceOracle);
    let client = PriceOracleClient::new(&env, &contract_id);

    let reflector_address = Address::from_string(&String::from_str(
        &env,
        "CAVLP5DH2GJPZMVO7IJY4CVOD5MWEFTJFVPD2YY2FQXOQHRGHK4D6HLP",
    ));

    client.initialize_oracle(&reflector_address);

    let asset = &Asset::Other(symbol_short!("BTC"));
    let price = client.fetch_price(asset);

    println!("{:?}", price.price);
}
```

### Makefile Commands

```makefile
default: build

all: test
test: build
	cargo test

build:
	stellar contract build
	@ls -l target/wasm32-unknown-unknown/release/*.wasm

snapshot:
	rm -rf snapshot.json
	stellar snapshot create --network mainnet --output json --address CAFJZQWSED6YAWZU3GWRTOCNPPCGBN32L7QV43XX5LZLFTK6JLN34DLN
```

## Conclusion

Reflector offers a secure and decentralized price oracle, suitable for DeFi applications. Developers should implement best practices to optimize reliability and mitigate risks.
